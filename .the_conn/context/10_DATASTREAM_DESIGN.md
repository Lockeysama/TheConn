# DataStream 高可靠低延迟信令传输方案设计

## 1. 概述与目标

本方案旨在解决基于 UDP 的 Agora DataStream 在弱网环境下的丢包问题，同时避免 TCP/WebRTC Reliable 模式带来的高延迟和队头阻塞（HOL Blocking）。

**适用场景**: 控制信令

**核心目标**:
- 高可靠：在 10% 丢包率下实现 >99.9% 的最终到达率
- 低延迟：无 ACK 确认机制，力求数据在首个 RTT 内送达
- 抗抖动：解决发送间隔不规律导致的尾部丢包问题
- 防堆积：内置应用层流量控制和拥塞感知能力

## 2. 核心设计原则

本方案放弃了复杂的 ACK/NACK 状态机，转而使用**"带宽换时效"**的策略：

1. **统一数组协议**: 所有传输单元均为数组，简化解析逻辑，天然支持拼包
2. **时间分集冗余**: 主动进行 3 次发送 (T+0ms, T+20ms, T+40ms)，规避网络瞬间拥塞
3. **动态历史捎带**: 新包自动捎带最近历史事件，修复"尾部丢包"

## 3. 系统架构

```
┌─────────────────────────────────────────────────────────────┐
│                      发送端 (Sender)                         │
├─────────────────────────────────────────────────────────────┤
│  业务层 → 发送缓冲队列 → 打包循环 → 冗余控制器 → UDP 网络    │
│                ↓              ↓                              │
│           历史窗口      拥塞感知策略                          │
└─────────────────────────────────────────────────────────────┘
                              ↓
                        Agora Network
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      接收端 (Receiver)                       │
├─────────────────────────────────────────────────────────────┤
│  UDP数据 → JSON解析 → Packet去重 → 排序 → Event去重 → 业务层 │
│              (Layer 1: 传输层)    (Layer 2: 业务层)          │
└─────────────────────────────────────────────────────────────┘
```

## 4. 协议结构设计

采用 JSON 格式，结构分为"头"和"体"：

```json
{
  "h": {
    "seq": 5001,          // 传输层包序号 (Uint32, 用于 UDP 去重)
    "ts": 167999999001    // 发送时间戳 (Int64, 毫秒级)
  },
  "d": [                  // Data List
    {
      "id": 101,          // 业务层事件 ID (Uint32/Uint64, 用于业务去重和排序)
      "event": "",
      "command": "",
      "intent": "",
      "data": null
    }
  ]
}
```

**字段说明**:
- `h.seq`: 负责 UDP 层面的去重
- `d[i].id`: 负责业务层面的去重和排序

## 5. 拥塞控制策略

根据队列积压量动态调整发送策略：

| 级别 | 队列积压 | 冗余策略 | 捎带策略 | 打包策略 | 目标 |
|------|---------|---------|---------|---------|------|
| Level 1 (健康) | < 5 | 3次冗余 | 启用 (3-5个) | 正常 | 最高可靠性 |
| Level 2 (繁忙) | 5~50 | 2次冗余 | 减少 (1个) | 强制拼包至 1KB 或 5ms | 平衡吞吐 |
| Level 3 (拥塞) | > 50 | 仅1次 | 关闭 | 贪婪填满 1KB | 防止断连 |

## 6. 可靠性数据支撑

假设单次 UDP 传输丢包率为 P = 10%，采用"3次冗余"策略：

**单事件到达率**:
```
1 - P³ = 1 - 0.1³ = 99.9%
```

**双事件自愈率 (捎带机制)**:
如果事件 A 的 3 次包全丢（概率 0.1%），但事件 B 的包捎带了 A 并送达（概率 99.9%）：
```
事件 A 最终丢失概率 = 0.001 × 0.001 = 0.000001 (百万分之一)
```

## 7. 实施要点

1. **Agora 参数**: 确认 DataStream 支持每秒 60-100 PPS，单包 < 1KB
2. **Header 设计**: PacketSeq 使用 Uint32，EventID 使用 Uint32/Uint64
3. **排序算法**: 接收端处理前执行 `sort.Slice(events, func(i,j) { return events[i].ID < events[j].ID })`
4. **历史窗口**: 保留最近 3-5 个事件或总大小 < 500 字节
5. **空闲保活**: 100ms 无操作时发送心跳包，仅装载历史捎带数据

## 8. 技术栈

- **传输层**: Agora DataStream (UDP)
- **协议格式**: JSON (可选 Protobuf 优化)
- **语言**: Go
- **并发模型**: goroutine + channel

## 9. 预期收益

| 场景 | 当前状态 | 优化后 |
|------|---------|--------|
| 10% 丢包率下信令到达率 | ~90% | >99.9% |
| 尾部丢包修复能力 | 无 | 自动修复 |
| 队头阻塞 | 存在风险 | 完全消除 |

