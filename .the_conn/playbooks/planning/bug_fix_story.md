# Bug Fix Story 生成指南

你是一位资深的质量工程师。你的任务是根据发现的 Bug，生成结构化的 Bug Fix Story 文件。

## ⚠️ 重要：遵守基础公约

**本 Playbook 严格遵守 `@rules/base_rules.md` 中定义的所有基础公约。**

**📋 规范引用**：

本 Playbook 依赖以下规范文件（AI 必须先加载）：
- **基础公约**: `@rules/base_rules.md` - 禁止事项、文件路径约定、质量标准
- **测试策略**: `@rules/test_strategy_rules.md` - Bug Fix Story 的测试策略

## 本 Playbook 的工作范围

**专注于**：

- ✅ **生成 Bug Fix Story 文档**：创建 Bug Fix Story 文件
- ✅ **编写修复方案**：描述修复思路和验收标准
- ✅ **使用代码片段**：可使用代码片段说明问题和修复方案

---

## 🔄 执行流程追踪

**AI 必须在执行过程中维护以下追踪表格**：

```markdown
## 🔄 Bug Fix 生成执行追踪

| Phase | 内容               | 状态 | 输出 | 备注   |
| ----- | ------------------ | ---- | ---- | ------ |
| 1     | 问题分析与根因定位 | ⏳    | -    | 待开始 |
| 2     | 修复策略设计       | ⏳    | -    | 待开始 |
| 3     | 生成 Story 文档    | ⏳    | -    | 待开始 |

**图例**：✅ 已完成 | 🔄 进行中 | ⏳ 等待中 | ❌ 失败
```

### Phase 1 & 2: 分析与策略

#### ✅ 分析与策略检查点

**AI 必须确认以下项目后才能进入文档生成**：

- [ ] **问题复现**: 场景、预期、实际行为描述清晰
- [ ] **根因定位**: 已定位到具体文件和函数
- [ ] **5-Why 分析**: 逻辑链条完整，找到根本原因
- [ ] **修复策略**: 包含短期修复和长期改进
- [ ] **副作用分析**: 已预演修复可能带来的波及影响
- [ ] **执行追踪表格**: Phase 1 & 2 状态为 ✅

---

## 使用场景

当以下情况发生时，应使用此模板：

1. 已完成的 Story 在集成/系统测试阶段发现缺陷
2. 生产环境发现的问题
3. 原 Story 的测试覆盖不足导致的边缘情况遗漏

---

---

## 输入

用户会提供以下材料：

- 父 Story ID（被修复的 Story）
- Bug 现象描述（测试场景、预期行为、实际行为）
- 影响范围

---

## 输出要求

### 1. 文件路径

```
.the_conn/epics/EPIC-{序号}_{Name}/features/FEAT-{序号}_{Name}/stories/STORY-{父序号}.{子序号}_{PascalCaseName}.md
```

**示例**: `.the_conn/epics/EPIC-01_Base_Init/features/FEAT-01_Init_Project/stories/STORY-01.1_Fix_Permission.md`

### 2. Bug Fix ID 规则

- **格式**: `STORY-{父序号}.{子序号}`
- **父序号**: 对应的父 Story 编号
- **子序号**: 该 Story 的 Bug 修复序号，从 1 开始
- **示例**: `STORY-01.1`, `STORY-01.2`, `STORY-05.1`

### 3. 文件命名规则

- **格式**: `STORY-{父序号}.{子序号}_{PascalCaseName}.md`
- **PascalCase**: 每个单词首字母大写，无分隔符
- **示例**: `STORY-01.1_Fix_Permission.md`, `STORY-02.1_Handle_Concurrency.md`

---

## 输出格式

```markdown
---
id: STORY-{父序号}.{子序号}
type: bug_fix
epic: EPIC-{序号}
feature: FEAT-{序号}
status: pending
created: yyyy-mm-dd
depends_on:
  - STORY-{父序号}
---

# Bug Fix: {问题简述}

## 1. 问题

**发现于**: {集成测试 / 系统测试 / 生产环境}

**现象**:
- 场景: {触发问题的条件}
- 预期: {应该发生什么}
- 实际: {实际发生什么}

**影响**: {对功能/用户/系统的影响}

## 2. 根因分析

**定位**: `{文件路径}` 的 `{函数/方法}`

### 5-Why 分析流程

```mermaid
graph TD
    Q1[为什么出现这个问题?] --> A1[直接原因:<br/>{表面现象}]
    A1 --> Q2[为什么会有这个直接原因?]
    Q2 --> A2[技术原因:<br/>{技术实现缺陷}]
    A2 --> Q3[为什么会存在这个技术问题?]
    Q3 --> A3[设计原因:<br/>{设计遗漏}]
    A3 --> Q4[为什么设计时没有考虑到?]
    Q4 --> A4[流程原因:<br/>{需求/测试遗漏}]
    A4 --> Q5[为什么需求或测试没有覆盖?]
    Q5 --> A5[根本原因:<br/>{流程/认知/资源}]
```

### 根因分析详细说明

| Why | 问题 | 原因 | 层次 |
|-----|------|------|------|
| 1 | 为什么出现这个问题? | {直接原因} | 表面现象 |
| 2 | 为什么会有这个直接原因? | {技术层面原因} | 技术实现 |
| 3 | 为什么会存在这个技术问题? | {设计层面原因} | 设计缺陷 |
| 4 | 为什么设计时没有考虑到? | {需求或测试层面原因} | 流程缺失 |
| 5 | 为什么需求或测试没有覆盖? | {根本原因} | 系统性问题 |

**根本原因总结**: {从系统性角度总结根本原因}

### 修复策略

| 策略类型 | 目标 | 措施 | 优先级 |
|---------|------|------|--------|
| 短期修复 | 快速恢复功能 | {解决表面问题的具体措施} | ✅立即 |
| 长期改进 | 防止再次发生 | {从根本原因入手的改进措施} | ⭐后续 |

## 3. 副作用分析 (Side Effect Analysis) 🆕
 
 ⚠️ **必须进行预演**:
 - [ ] **权限变更**: 如果修改了权限，是否会影响正常用户的访问？
 - [ ] **数据变更**: 如果修改了数据格式，旧数据兼容吗？API 响应变了吗？
 - [ ] **性能影响**: 修复逻辑会增加延迟吗？
 
 ## 4. 修复

**方案**: {简要说明修复思路}

**验收标准（测试清单）**:

- [ ] 修复验证：在 {复现条件} 下执行 {触发动作}，{修复后的正确行为}
- [ ] 回归验证（关键）：
    - 验证关联功能 {功能A} 正常工作
    - 验证关联功能 {功能B} 正常工作
    - 验证数据迁移/兼容性（如适用）
- [ ] 单元测试：新增/修改测试用例覆盖此 Bug 场景
- [ ] 测试通过：所有相关测试通过，代码通过 linter 检查

**验证方式**：
- 运行单元测试套件
- 手动验证 Bug 已修复
- 回归测试确认无副作用

**涉及文件**:
- `{文件路径}` - {说明}

**边界**:
- 禁止修改: {范围}
```

---

## Frontmatter 字段说明

**所有字段均为必填！**

| 字段         | 类型   | 说明           | 示例             | 约束                            |
| --- | --- | --- | --- | --- |
| `id`         | string | Bug Fix ID     | `STORY-01.1`     | 格式: `STORY-{父序号}.{子序号}` |
| `type`       | enum   | 固定为bug_fix  | `bug_fix`        | **必须**是`bug_fix`             |
| `epic`       | string | 所属Epic ID    | `EPIC-01`        | -                               |
| `feature`    | string | 所属Feature ID | `FEAT-01`        | -                               |
| `status`     | enum   | 状态           | `pending`/`done` | **只能**是`pending`或`done`     |
| `created`    | date   | 创建日期       | `2025-12-11`     | 格式**必须**是`yyyy-mm-dd`      |
| `depends_on` | array  | 父Story ID     | `[STORY-01]`     | **第一个元素必须**是父Story ID  |

---

## 生成原则

1. **问题清晰**: 现象描述要足够详细，能复现问题
2. **追溯关系**: `depends_on` 的第一个元素必须是父 Story ID
3. **验收聚焦**: 测试清单必须包含修复验证和回归验证
4. **范围最小**: 只修复问题，不做额外重构
5. **命名规范**: 使用 PascalCase 命名
6. **测试先行**: 先写测试复现 Bug，再修复代码

---

## 示例（文件权限问题）

```markdown
---
id: STORY-01.1
type: bug_fix
epic: EPIC-01
feature: FEAT-01
status: pending
created: 2025-12-11
depends_on: [STORY-01]
---

# Bug Fix: 修复文件权限问题

## 1. 问题
**发现于**: 集成测试
**现象**: 场景(Linux初始化) | 预期(0644权限) | 实际(0600权限)
**影响**: 其他用户无法读取配置文件

## 2. 根因分析
**定位**: `src/theconn/init.py` 的 `create_file()`

**5-Why**:
1. 为什么权限是0600？ → 使用默认open()权限，未显式设置
2. 为什么没显式设置？ → 代码未考虑权限需求
3. 为什么代码没考虑？ → 原Story验收标准无权限要求
4. 为什么验收标准没有？ → 测试只在单用户环境，未覆盖多用户
5. 为什么测试没覆盖？ → 测试设计缺少对部署环境考虑

**根本原因**: 测试用例设计不足，未考虑生产环境多用户场景

**修复策略**:
- 短期: 使用os.chmod()显式设置0644
- 长期: 1.增加多用户测试模板 2.统一权限配置策略 3.Code Review增加权限检查

## 3. 修复
**方案**: 使用os.chmod()显式设置文件权限为0644

**验收标准**:
- [ ] 修复验证: Linux初始化，文件权限=0644
- [ ] 权限验证: 其他用户能读取文件
- [ ] 回归验证: 跨平台(Linux/macOS/Windows)文件创建成功
- [ ] 单元测试: 新增权限验证测试用例
- [ ] 测试通过: 所有测试通过+linter检查

**涉及文件**:
- `src/theconn/init.py` - 修改create_file()
- `tests/test_init.py` - 新增权限测试

**边界**: 禁止修改其他初始化逻辑
```

---

## ✅ Bug Fix Story 生成后检查清单

**AI 必须在生成 Story 文档后执行以下检查**：

### 基础检查
- [ ] **文件路径正确**: `.the_conn/epics/.../stories/STORY-XX.Y_*.md`
- [ ] **ID 格式正确**: `STORY-{父序号}.{子序号}`
- [ ] **Type 正确**: 固定为 `bug_fix`
- [ ] **Depends On**: 第一个元素包含父 Story ID

### 内容检查
- [ ] **问题描述**: 包含场景、预期、实际、影响
- [ ] **根因分析**: 包含 5-Why 分析表和根本原因总结
- [ ] **副作用分析**：包含了对权限/数据/性能的波及预演
- [ ] **修复方案**: 明确的代码修改思路
- [ ] **验收标准**: 包含修复验证、回归验证、单元测试

### 质量检查
- [ ] **范围控制**: 仅修复 Bug，未引入无关重构
- [ ] **测试覆盖**: 明确了新增/修改的测试用例
- [ ] **执行追踪表格**: 所有 Phase 状态为 ✅

---

现在，请根据用户提供的 Bug 信息生成 Bug Fix Story。

---

## Phase 4: 自动衔接 (Router Compliance) 🆕

**⚠️ 重要：本 Playbook 作为 Quick 流程的一部分，必须执行 `quick_router.md` 定义的自动衔接逻辑。**

### 4.1 衔接菜单

Story 生成并确认无误后，**必须**输出以下标准菜单供用户选择：

```markdown
✅ Story 已生成: `.the_conn/epics/.../STORY-{ID}_*.md`

🚀 **Quick 模式 - 自动衔接**

由于这是 Quick Change（单个 Story），我可以为你自动完成：

**选项 1: 自动衔接（推荐）**
✅ 自动生成 Task 简报（gtask）
✅ 自动执行开发任务（etask）
✅ 等待你 Review 后完成闭环

**选项 2: 仅生成 Story**
⏸️  暂停，稍后手动执行 `tc gtask` 和 `tc etask`

**选项 3: 修改 Story**
✏️  调整 Story 内容后再决定

请选择 [1/2/3] 或输入 [继续/暂停/修改]:
```

### 4.2 执行逻辑

根据用户选择，严格执行以下分支：

| 用户选择 | AI 行为 |
| :--- | :--- |
| **1 / 继续** | 1. 初始化 "Quick 自动衔接追踪" 表格 (见下文)<br/>2. 加载 `@playbooks/execution/task_generation.md`<br/>3. 传递 Story 路径参数 |
| **2 / 暂停** | 输出后续手动命令提示，结束任务。 |
| **3 / 修改** | 询问具体修改点，修改 Story 后**重新**展示衔接菜单 (回到 4.1)。 |

**Quick 自动衔接追踪表格** (仅当选择 1 时初始化):

```markdown
## 🔗 Quick 自动衔接追踪

**当前工作流**: quick_router → (本playbook) → task_generation

| Step | Playbook        | 状态 | 说明             |
| ---- | --------------- | ---- | ---------------- |
| 1    | task_generation | 🔄    | 正在加载并执行... |
| 2    | task_execution  | ⏳    | 等待 Step 1 完成 |

(AI 需将此状态传递给下一个 Playbook)
```

