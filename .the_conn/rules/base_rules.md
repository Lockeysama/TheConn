# The Conn Playbooks 基础公约

本文档定义了所有 AI Playbooks 必须遵守的基础规则和约束。

**重要性**：所有 Playbook 都必须严格遵守本公约，除非在特定 Playbook 中有明确的例外说明。

---

## 1. 核心原则

### 1.0 文件加载强制要求 🔴

**在执行任何命令之前，AI 必须按照以下分层策略加载上下文文件**：

#### 第一层：核心公约（所有命令必须加载）

```
rules/base_rules.md
```

**说明**：定义了所有 Playbook 必须遵守的基础规则和约束

#### 第二层：具体 Playbook

加载命令对应的 playbook 文件（通过 tc.md 的命令路由表映射）

#### 第三层：领域规范（按 Playbook 声明加载）

每个 Playbook 在开头的 **"📋 规范引用"** 部分声明了自己依赖的规范文件。

AI 必须按照 Playbook 的声明加载对应的规范文件。

**⚠️ 重要：去重加载**
- 同一个规范文件只加载一次，避免重复
- 如果多个 playbook 引用同一规范，AI 应自动去重
- 已加载的文件不需要重新加载

#### 第四层：项目上下文（按需加载）

由具体 playbook 决定是否加载：
- Epic/Feature/Story 规划文件
- Context 文档（`.the_conn/context/`）
- 用户文档（`.the_conn/docs/`）
- 项目配置文件

#### 第五层：用户引用文件

检查并加载用户 Prompt 中所有被 `@` 引用的文件

**重要区分**：
- ✅ **用户 Prompt 中的 @ 引用**：用户在对话中显式输入的 `@文件名`，这些需要加载
- ❌ **Playbook 文档内部的路径**：文档内部的路径说明（如表格中的 `planning/xxx.md`）是指令，不是引用，不需要额外加载

**执行流程**：

```
用户输入命令
    ↓
第一层：加载 base_rules.md
    ↓
第二层：加载目标 playbook
    ↓
第三层：按 playbook 声明加载规范文件（去重）
    ↓
第四层：加载 playbook 要求的项目上下文
    ↓
第五层：加载用户 @ 引用的文件
    ↓
执行 playbook 任务
```

---

### 1.1 职责分离原则

- **规划与实现分离**：规划阶段只生成文档，实现阶段才编写代码
- **意图与执行分离**：人类定义"做什么"，AI 执行"怎么做"
- **文档与代码同步**：确保规划文档与代码实现保持一致

### 1.2 The Conn 工作流

```
规划阶段 (Playbooks)
    ↓ 生成文档
Task 执行阶段 (唯一允许编写代码的环节)
    ↓ 编写实现
同步阶段 (Playbooks)
    ↓ 更新文档
```

---

## 2. 严格禁止事项 ❌

### 2.1 代码实现

**禁止编写以下类型的代码**：

- ❌ 实际的业务逻辑实现代码
- ❌ 实际的测试实现代码（BDD step definitions、单元测试）
- ❌ 构建脚本、部署脚本
- ❌ 配置文件的具体实现

**例外**：只有 `execution/task_generation.md` Playbook 可以指导 AI 编写代码。

### 2.2 文件修改限制

**严格禁止修改以下目录/文件**：

- ❌ `.the_conn/docs/` 目录下的所有文件（用户文档）
- ❌ 项目源代码目录（除 .the_conn 以外的所有文件但不包括用户指定的存储目录）
- ❌ 已存在的测试代码

**例外**：

- ✅ 可以创建新的规划文档（epics/、context/ 目录）
- ✅ 可以更新 Story 状态（story_sync.md）
- ✅ 可以生成临时工作文件（ai_workspace/ 目录）

### 2.3 操作限制

**禁止执行以下操作**：

- ❌ 执行任何开发任务（编译、构建、测试）
- ❌ 修改项目依赖配置（package.json、requirements.txt、go.mod 等）
- ❌ 执行 Git 操作（commit、push、branch 等）
- ❌ 部署或发布操作

---

## 3. 允许事项 ✅

### 3.1 设计说明中的代码片段

**允许在文档中使用代码片段来说明设计**：

- ✅ 接口定义（interface、protocol）
- ✅ 数据结构定义（struct、class、type）
- ✅ API 签名（function signature）
- ✅ 示例代码（用于说明用法）
- ✅ 伪代码（用于说明算法）

**关键区别**：

```markdown
✅ 允许（设计说明）：
```go
// 接口定义
type Sender interface {
    Send(event Event) error
}
```

❌ 禁止（实际实现）：

```go
// 完整的实现代码
func (s *DefaultSender) Send(event Event) error {
    // 实现逻辑
    return s.queue.Push(event)
}
```

### 3.2 文档操作

**允许创建和修改以下文档**：

- ✅ Epic/Feature/Story 规划文档
- ✅ Context 文档（设计、架构、技术方案）
- ✅ Task 工作文档（ai_workspace/ 目录）
- ✅ 变更摘要、同步文档

---

## 4. 文件路径约定

### 4.1 目录结构

```
.the_conn/
├── docs/                # 用户文档（禁止修改）
├── playbooks/           # AI 操作剧本（本文件所在目录）
├── context/             # 知识库（可创建和修改）
├── epics/               # 规划文档（可创建和修改）
└── ai_workspace/        # 临时工作区（可创建和修改）
```

---

## 5. 文档生成规范

### 5.1 Markdown 格式

- 使用标准 Markdown 语法
- 代码块必须指定语言（如 ```go、```python）
- 表格必须对齐
- 使用合适的标题层级（# ## ### ####）

### 5.2 语言使用规范

**核心原则**：AI 默认使用用户对话语言生成所有文档。

**基本规则**：

- 中文对话 → 中文文档
- 英文对话 → 英文文档
- 技术术语保持项目约定（通常为英文）

### 5.3 命名规范

**核心原则**：所有代码和代码文件的命名必须使用英文。

**强制要求**：

- ✅ 函数名必须使用英文（驼峰命名或下划线命名）
- ✅ 变量名必须使用英文
- ✅ 类名/结构体名必须使用英文
- ✅ 接口名/协议名必须使用英文
- ✅ 代码文件名必须使用英文（如 `.py`、`.go`、`.ts` 等）
- ✅ 目录名必须使用英文（项目源代码目录）

**禁止使用**：

- ❌ 禁止使用中文、日文、韩文等非英文字符命名函数
- ❌ 禁止使用中文、日文、韩文等非英文字符命名代码文件
- ❌ 禁止使用拼音命名（除非是特定的专有名词）

**示例**：

```python
# ✅ 正确
def calculate_total_price(items):
    pass

# ❌ 错误
def 计算总价(items):
    pass

# ❌ 错误
def jisuanZongjia(items):
    pass
```

**例外**：

- 文档文件（`.md`）可以使用中文命名
- 测试数据、配置文件中的字符串内容可以使用任何语言
- 注释和文档字符串可以使用任何语言

**原因**：

- 保证代码的跨团队、跨地区可读性
- 避免编码问题和兼容性问题
- 符合国际化开发标准和最佳实践

---

### 5.4 BDD 语言规范 ✨

**核心原则**：BDD Feature 文件必须保持技术关键字的标准化和业务描述的本地化。

**强制要求**：

- ✅ **关键字 (Keywords)**: 统一使用英文 (`Feature`, `Scenario`, `Given`, `When`, `Then`, `And`, `But`, `Background`, `Examples`, `Scenario Outline` 等)。
- ✅ **描述 (Descriptions)**: 使用项目交互的自然语言（AI 应优先遵循项目 Context 指定，或根据用户对话语言自动适配，参考 `@rules/bdd_language_rules.md`）。
- ✅ **禁止翻译**: 严禁将 Gherkin 关键字翻译为其他语言。

**原因**：

- 保证跨 BDD 测试框架的兼容性（所有框架原生支持英文关键字）。
- 降低环境配置和插件支持的复杂度。
- 确保业务逻辑能被团队成员清晰理解。

---

## 6. 与用户交互规范

### 6.1 讨论与决策

- **主动质疑**：对不合理的需求要勇于指出
- **提供选项**：给出 2-3 个方案供用户选择
- **等待确认**：重大决策前必须等待用户确认
- **记录决策**：重要的技术决策要记录理由

### 6.2 输出格式

- **清晰分段**：使用标题、列表、表格组织内容
- **突出重点**：使用 ⚠️、✅、❌ 等符号标记重要信息
- **简洁明了**：避免冗长的解释，突出关键信息

---

## 7. 质量标准

### 7.1 文档质量

- ✅ 语言精炼，表达准确
- ✅ 结构清晰，层次分明
- ✅ 格式规范，易于阅读
- ✅ 内容完整，无遗漏

### 7.2 设计质量

- ✅ 遵循 KISS 原则（Keep It Simple, Stupid）
- ✅ 避免过度设计
- ✅ 考虑可维护性和可扩展性
- ✅ 基于最佳实践

---

## 8. 检查清单

**在完成 Playbook 执行前，自检以下项目**：

- [ ] 是否遵守了所有禁止事项？
- [ ] 是否修改了 `docs/` 目录？（禁止！）
- [ ] 是否编写了实现代码？（禁止！）
- [ ] 生成的文档格式是否规范？
- [ ] Frontmatter 是否完整？
- [ ] ID 命名是否符合规范？
- [ ] 是否使用了复杂度评分而非时间估算？

---

## 9. 例外情况

### 9.1 Task 执行阶段

**唯一例外**：`execution/task_generation.md` 生成的 Task 简报会指导 AI 编写实际代码。

这是 The Conn 框架中**唯一允许编写实现代码的环节**。

### 9.2 紧急修复

在极特殊情况下（如安全漏洞修复），可以在用户明确授权后突破某些限制，但必须：

1. 获得用户明确授权
2. 详细记录例外原因
3. 事后同步更新文档

---

## 10. 流程追踪机制 📊

### 10.1 追踪的重要性

**所有包含多步执行流程或衔接其他 Playbook 的 Playbook 必须实施流程追踪机制。**

**目的**：
1. **透明性** - 用户随时知道 AI 在执行哪一步
2. **可控性** - 用户可以在关键点介入
3. **可追溯** - 失败时快速定位问题
4. **标准化** - 统一的追踪格式和更新规则

### 10.2 追踪类型

#### A. 执行流程追踪

**适用场景**：Playbook 内部有多个步骤（Step/Phase）

**标准格式**：
```markdown
## 🔄 {Playbook 名称} 执行追踪

| Step/Phase | 内容 | 状态 | 输出 | 备注 |
|------------|------|------|------|------|
| 1          | XXX  | ⏳   | -    | 待开始 |
| 2          | XXX  | ⏳   | -    | 待开始 |

**图例**：✅ 已完成 | 🔄 进行中 | ⏳ 等待中 | ❌ 失败
```

**更新规则**：
- 进入某个 Step → 状态更新为 🔄
- 完成某个 Step → 状态更新为 ✅，填写输出
- Step 失败 → 状态更新为 ❌，记录失败原因

#### B. 衔接追踪

**适用场景**：Playbook 会调用其他 Playbook

**标准格式**：
```markdown
## 🔗 {工作流名称} 衔接追踪

**当前工作流**: {当前 Playbook} → {后续流程}

| Step | Playbook | 状态 | 输出 | 备注 |
|------|----------|------|------|------|
| 1    | {下一个 Playbook} | ⏳ | - | 待开始 |
| 2    | {再下一个 Playbook} | ⏳ | - | 待开始 |

**图例**：✅ 已完成 | 🔄 进行中 | ⏳ 等待中 | ❌ 失败

**预计剩余步骤**: {N} 个
```

**更新规则**：
- 进入某个 Playbook → 状态更新为 🔄
- 完成某个 Playbook → 状态更新为 ✅，填写输出，更新"预计剩余步骤"
- Playbook 失败 → 状态更新为 ❌，暂停衔接，询问用户处理方式

**⚠️ 重要约定**：
- 衔接追踪表格**只包含被调用的其他 Playbook**
- **不包含当前 Playbook 自身**（当前 Playbook 的执行在"执行流程追踪"中体现）
- "当前工作流"说明可以提到当前 Playbook（如 `context/add → context/update`）

### 10.3 状态图例标准

**必须使用以下统一的状态图例**：

| 图标 | 含义 | 使用场景 |
|------|------|----------|
| ✅ | 已完成 | Step/Playbook 成功完成 |
| 🔄 | 进行中 | Step/Playbook 正在执行 |
| ⏳ | 等待中 | Step/Playbook 尚未开始 |
| ❌ | 失败 | Step/Playbook 执行失败 |
| ⚠️ | 警告 | Step/Playbook 有警告（可选） |

### 10.4 何时需要追踪

**必须实施追踪**：
- ✅ Playbook 有 3 个以上的执行步骤
- ✅ Playbook 会调用其他 Playbook（衔接）
- ✅ Playbook 是核心工作流的一部分

**无需追踪**：
- ❌ 单一任务的简单 Playbook（如 change_summary、story_sync）
- ❌ 工具类 Playbook（如 context/search）
- ❌ 查询类 Playbook（如 project_status）

### 10.5 异常处理标准

**当 Step/Playbook 失败时**，必须：

1. 更新状态为 ❌
2. 记录失败原因
3. 提供处理选项
4. 暂停流程，等待用户决策

**异常处理模板**：
```markdown
❌ {Step/Playbook} 执行失败

**失败原因**: {具体错误信息}

**当前状态**：
- ✅ {已完成的 Step 列表}
- ❌ {失败的 Step}
- ⏳ {未开始的 Step 列表}

**处理选项**：
1. 重试
2. 跳过，继续下一步
3. 终止流程

请选择 [1/2/3]:
```

### 10.6 追踪的强制性

**AI 必须**：
- ✅ 在适用的 Playbook 中维护追踪表格
- ✅ 实时更新追踪状态
- ✅ 遵循统一的格式和图例
- ✅ 在失败时使用标准异常处理模板

**AI 不得**：
- ❌ 跳过追踪更新
- ❌ 使用非标准的状态图例
- ❌ 在衔接追踪中包含当前 Playbook 自身
- ❌ 忽略失败状态

### 10.7 示例

**好的执行流程追踪**：
```markdown
## 🔄 Task 生成执行追踪

| Phase | 内容 | 状态 | 输出 | 备注 |
|-------|------|------|------|------|
| 1     | Story 内容分析 | ✅ | 关键词: 5 个 | 已完成 |
| 2     | Context 文件搜索 | 🔄 | - | 正在搜索... |
| 3     | 文件列表整合 | ⏳ | - | 待开始 |
```

**好的衔接追踪**：
```markdown
## 🔗 完整拆解流程衔接追踪

**当前工作流**: requirements_review → 完整拆解流程

| Step | Playbook | 状态 | 输出 | 备注 |
|------|----------|------|------|------|
| 1    | epic_init | ✅ | EPIC-01 已创建 | 已完成 |
| 2    | context/add | 🔄 | - | 正在提取 Global Context... |
| 3    | requirements_breakdown | ⏳ | - | 待开始 |

**预计剩余步骤**: 2 个
```

---

## 遵守声明

**所有 Playbook 在开头应包含以下声明**：

```markdown
## ⚠️ 重要：遵守基础公约

本 Playbook 严格遵守 `@rules/base_rules.md` 中定义的所有基础公约。
```

---

**最后更新**: 2025-12-23
**维护者**: The Conn Framework Team
